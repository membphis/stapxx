#!/usr/bin/env stap++

@use nginx.lua
@use luajit

global states, total, ignored, matched

function process_timer_event()
{
    if (@defined(@var("globalL", "$^exec_path"))) {
        mL = @var("globalL", "$^exec_path")

    } else {
        mL = ngx_lua_get_main_lua_vm()
    }

    if (mL == 0) {
        ignored++
        return 0
    }

    g = luajit_G(mL)
    if (g == 0) {
        ignored++
        return 0
    }

    $*g := @cast(g, "global_State", "$^libluajit_path")

    gco = $*g->cur_L->gcptr32
    $*gco := @cast(gco, "GCobj", "$^libluajit_path")

    L = &$*gco->th
    $*L := @cast(L, "lua_State", "$^libluajit_path")

    if (L == 0) {
        ignored++
        return 0
    }

    /*
    printf("cur L: %p\n", L)
    printf("vmstate: %d\n", $*g->vmstate)
    printf("cframe: %p\n", $*L->cframe)
    */

    vmstate = $*g->vmstate
    matched = 1
    if (vmstate >= 0) {
        /* compiled Lua code */
        states[pid(), "N"]++
        total[pid()]++

    } else {
        if (vmstate == -1 && !$*L->cframe) {
            ignored++

        } else {
            if (vmstate == -1) {
                states[pid(), "I"]++

            } else if (vmstate == -2) {
                states[pid(), "C"]++

            } else if (vmstate == -3) {
                if ($*g->jit_base->ptr32) {
                    states[pid(), "NG"]++

                } else {
                    states[pid(), "G"]++
                }

            } else if (vmstate == -4) {
                states[pid(), "E"]++

            } else {
                states[pid(), "J"]++
            }

            total[pid()]++
        }
    }

    return 1
}

probe timer.profile
{
    if ($^pid_ok) {
        process_timer_event()
    }
}

function gen_report()
{
    foreach ([p_id, state] in states-) {
        printf("\nObserved %d Lua-running samples and ignored %d unrelated samples.\n",
           total[p_id], ignored)


        if (state == "I") {
            ctx = "Interpreted"

        } else if (state == "N") {
            ctx = "Compiled"

        } else if (state == "J") {
            ctx = "JIT Compiler"

        } else if (state == "C") {
            ctx = "C Code (by interpreted Lua)"

        } else if (state == "E") {
            ctx = "Trace exiting"

        } else if (state == "NG") {
            ctx = "Garbage Collector (compiled)"

        } else {
            /* state == "G" */
            ctx = "Garbage Collector (not compiled)"
        }

        count = states[p_id, state]
        printf("%s: %d%% (%d samples)\n", ctx, count * 100 / total[p_id], count)
    }
}

probe end
{
    if (matched != 1) {
        printf("\nNo Lua-running samples observed.\n")

    } else {
        gen_report()
    }
}

probe begin
{
    printf("Start tracing %d ($^exec_path)\n", target())
    %( "$^arg_time :default()" != ""  %?
    printf("Please wait for $^arg_time seconds...\n")
    %:
    printf("Hit Ctrl-C to end.\n")
    %)
}

%( "$^arg_time" != ""  %?
probe timer.s($^arg_time) {
    exit()
}
%)
