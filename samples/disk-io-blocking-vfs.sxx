#!/usr/bin/env stap++

# Measure the distribution of the VFS read/write latency.

global begin, stats, found, latency

probe syscall.lseek, syscall.renameat, syscall.open, syscall.close, syscall.sendfile*
      vfs.read*, vfs.write*, syscall.*stat*, syscall.unlink, syscall.mkdir, syscall.rmdir
{
    if (sprintf("%d", pid()) =~ "^($^target)$") {
        begin[pid()] = gettimeofday_us()
        found = 1
    }
}

probe syscall.lseek.return, syscall.renameat.return, syscall.open.return, syscall.close.return, syscall.sendfile*.return,
      vfs.read*.return, vfs.write*.return, syscall.*stat*.return, syscall.unlink.return, syscall.mkdir.return, syscall.rmdir.return
{
    if (sprintf("%d", pid()) =~ "^($^target)$" && begin[pid()] > 0) {
        latency = gettimeofday_us() - begin[pid()]
        stats[pid()] <<< latency
        if (latency > 256) {
            printf("\n\npid: %d latency: %dus", pid(), latency)
            print_ubacktrace()
        }
    }
}

probe timer.s($^arg_time :default(5)) {
    exit()
}

probe end {

    if (found != 1) {
        printf("No samples observed so far.\n");

    } else {
        printf("Distribution of disk read/write blocking latencies (in microseconds)\n")

        foreach (pro_id in stats) {
            printf("pid %d:\n", pro_id)
            printf("max/avg/min: %d/%d/%d\n", @max(stats[pro_id]), @avg(stats[pro_id]), @min(stats[pro_id]))
            print(@hist_log(stats[pro_id]))
        }
    }
}

probe begin {
    printf("Start tracing %d ($^exec_path)...\nPlease wait for %d seconds.\n\n",
           target(), $^arg_time)
}
